import networkx as nx
import random

from coincollector_mazes.get_maze import get_maze, print_maze_info, add_shortest_path_info


def identify_dangling_rooms(G: nx.DiGraph) -> dict:
    '''
    Identifies rooms which have exactly one adjacent room.

    Args:
        G: A network-x DiGraph

    Returns:
        A dictionary with keys 0, 1, 2, 3, where key 0 [1/2/3] gives a list of string room names ('r_0', 'r_6' etc.) that have exactly one adjacent room and are north [east/south/west] of that adjacent room.
    '''
    dangling_rooms = {
        0: [],
        1: [],
        2: [],
        3: []
    }
    for node in G.nodes():
        out_edges = list(G.edges(node))

        if len(out_edges) == 1: # this means room is dangling
            dangling_direction = G.get_edge_data(*out_edges[0])['direction']
            dangling_rooms[dangling_direction] += [node]

    return dangling_rooms

def generate_exit_sentence(direction: int) -> str:
    sentences = [
        'There is an unguarded exit to the $.',
        'There is an unblocked exit to the $.',
        "There is an exit to the $.Don't worry, it is unguarded.",
        "There is an exit to the $.Don't worry, it is unblocked.",
        "You don't like doors? Why not try going $, that entranceway is unguarded.",
        "You don't like doors? Why not try going $, that entranceway is unblocked.",
    ]
    directions = ['north','east','south','west']
    sent = random.choice(sentences).replace('$', directions[direction])
    return sent

def count_left_right_turns(G: nx.DiGraph, path: list) -> tuple:
    left_turns = 0
    right_turns = 0
    for k in range(len(path)-2):
        if (G[path[k]][path[k+1]]['direction']+1)%4 == G[path[k+1]][path[k+2]]['direction']:
            right_turns += 1
        elif (G[path[k]][path[k+1]]['direction']-1)%4 == G[path[k+1]][path[k+2]]['direction']:
            left_turns += 1
    return left_turns, right_turns

def determine_relative_room_position(G: nx.DiGraph, room1, room2, dangling_direction) -> int:
    connecting_path = nx.shortest_path(G, source=room1, target=room2)
    left_turns, right_turns = count_left_right_turns(G, connecting_path)
    if left_turns > right_turns: # start west/south of end
        return ((dangling_direction + 1) % 2) + 2  # if dangling south, then (2+1%2)+2=3 -> west
    elif left_turns < right_turns: # start north/east of end
        return (dangling_direction + 1) % 2  # if dangling south, then (2+1)%2=1 -> east
    elif left_turns == right_turns:
        # find the first step orthogonal to dangling direction
        for k in range(len(connecting_path)-1):
            if G[connecting_path[k]][connecting_path[k+1]]['direction']%2 == (dangling_direction+1)%2:
                first_orthogonal_step_direction = G[connecting_path[k]][connecting_path[k+1]]['direction']
                return first_orthogonal_step_direction

def dangling_room_list_depleted(dangling_rooms):
    for k in [0, 1, 2, 3]:
        if len(dangling_rooms[k]) < 2:
            return True
    return False

def add_new_edges(G: nx.DiGraph, number_of_new_edges: int, seed: int) -> nx.DiGraph:
    '''
    Adds new edges to a Coin-Collector maze to create circles in the graph.

    Args:
        G: A network-x graph representing a Coin-Collector world as generated by the function get_maze in coincollector_mazes.get_maze.
        number_of_new_edges: The number of new edges to be added. If more than one edge is added the maze may no longer be drawable in a grid. If one edge is added, it is added in such a way that the maze is still drawable in a grid. If this number is higher than can be constructed from joining dangling rooms an information is printed to stdout and the maximum possible number of circles is generated.
        seed: Random seed for choice of where to add the edge.

    Returns:
        A network-x graph representing a Coin-Collector world containing at least one circle if number_of_new_edges>=1.
    '''
    dangling_rooms = identify_dangling_rooms(G)
    random.seed(seed)
    circles_requested = number_of_new_edges
    while number_of_new_edges > 0 and not dangling_room_list_depleted(dangling_rooms):
        direction_choices = [0, 1, 2, 3]
        random.shuffle(direction_choices)
        for direction in direction_choices:
            random.shuffle(dangling_rooms[direction])
            if len(dangling_rooms[direction]) >= 2 and number_of_new_edges > 0:
                room1 = dangling_rooms[direction].pop()
                room2 = dangling_rooms[direction].pop()

                new_edge_direction = determine_relative_room_position(G, room1, room2, direction)

                # print('New edge: (%s, %s, direction=%s)' % (room1, room2, (new_edge_direction+2)%4))
                G.add_edge(
                    room1,
                    room2,
                    direction=(new_edge_direction+2)%4,
                    contained_in_shortest_path=0
                )
                G.add_edge(
                    room2,
                    room1,
                    direction=new_edge_direction,
                    contained_in_shortest_path=0
                )

                # print('Old rooms:')
                # print(G.nodes[room1])
                # print(G.nodes[room2])

                G.nodes[room1]['description'] = G.nodes[room1]['description'] + generate_exit_sentence(new_edge_direction % 4)
                G.nodes[room2]['description'] = G.nodes[room2]['description'] + generate_exit_sentence(
                    (new_edge_direction + 2)%4)

                # print('New rooms:')
                # print(G.nodes[room1])
                # print(G.nodes[room2])

                number_of_new_edges -= 1

    print('Circles requested: %s. Circles constructed: %s.' % (circles_requested, number_of_new_edges))
    # shortest path may have changed
    G = add_shortest_path_info(G)
    return G

def test_maze_refinement():
    G = get_maze(104, 100)
    print_maze_info(G)
    G = add_new_edges(G, 1, 100)
    print_maze_info(G)
    print("Edge ('r_4', 'r_5') was added with correct direction info")


if __name__ == '__main__':
    G = get_maze(250, 100)
    G = add_new_edges(G, 5, 100)
